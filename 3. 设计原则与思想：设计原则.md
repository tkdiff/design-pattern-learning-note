# 设计原则与思想

> 本文是 《设计模式之美》 - 设计原则与思想：设计原则的学习笔记。

## 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？

### 如何理解单一职责原则（SRP）？

`SRP`: Single Responsibility Principle

一个类或者模块只负责完成一个职责或者功能。也就是说不要设计大而全的类。

### 如何判断类的职责是否足够单一 ？

* 类中的代码行数、函数或者属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
* 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
* 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
* 比较难给类起一个合适的名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
* 类中大量的方法都是集中操作类中某几个属性，比如，在 UserInfo 例子中，如果一般的方法都在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。

### 类的职责是否设计得越单一越好 ？

单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是如果拆分得过细，实际上适得其反，反倒会降低内聚性，也会影响代码的可维护性。

## 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

### 1. 如何理解 “对扩展开放、对修改关闭” ?

添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、定义、属性等），而非修改已有代码（修改模块、类、定义、属性等）的方式来完成。

* 开闭原则并不是完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发；
* 统一的代码改动，在粗代码粒度下，可能被认定为 “修改”；在细代码粒度下，可能又被认定为 “扩展”。

### 2. 如何做到 “对扩展开放、对修改关闭” ？

我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间来思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。 很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。 最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

## 17 | 理论三：里式替换（LSP）跟多态有何区别？哪些代码违背了LSP？

### 里氏替换原则 （Liskov Substitution Principle）

子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。

### 哪些代码明显违背了 LSP 原则

* 1. 子类违背父类声明要实现的功能
* 1. 子类违背父类对输入、输出、异常的约定
* 1. 子类违背父类注释中所罗列的任何特殊说明

## 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

### 1. 如何理解“接口隔离原则”？

“接口“可以有3种不同的理解：

* 理解为一组接口组合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
* 理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更新额多个函数，让调用者只依赖它需要的那个细粒度函数。
* 理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

### 2. 接口隔离原则与单一职责原则的区别

单一职责原则针对的是模块、类、接口的设计。 接口隔离原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。 接口隔离原则提供了一种判断接口的职责是否单一的标准： 如果调用者通过只是用部分接口或者接口的部分功能，那接口的设计就不够职责单一。

## 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

### 1. 控制反转

控制反转是一种比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

### 2. 依赖注入

依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。

### 3. 依赖注入框架

依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

### 4. 依赖反转原则

依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

## 20 | 理论六：我为何说KISS、YAGNI原则看似简单，却经常被用错？

### KISS 原则

Keep It Simple and Stupid. 尽量保持简单。

* 不要使用同事可能不懂的技术来实现代码；
* 不要重复造轮子，要善用已经有的工具类库；
* 不要过度优化。不要过度使用一些奇巧淫技来优化代码，牺牲代码的可读性。

### YAGNI 原则

You Ain’t Gonna Need It. 你不会需要它。 KISS 原则讲的是“如何做”的问题，而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。

## 总结

![编程方法论](https://seven-blog-2019.oss-cn-beijing.aliyuncs.com/编程方法论.png)

